# -*- coding: utf-8 -*-
"""Variational_Quantum_Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IPDOdVJafTv-8HyPi6CNVgo8F-VKV-kU

Variational quantum computing exploits the advantages of both classical computing and quantum computing. In a very general sense, we propose an initial solution to a problem, called an ansatz. In our case our ansatz will be an ansatz parametrised by a and b. We then prepare our qubits (the quantum equivalent of bits on a normal computer) and test how good the ansatz is, using the quantum computer. Testing the ansatz equates to minimising a cost function. We feed the result of this cost function back to the classical computer, and use some classical optimisers to improve on our ansatz, i.e. our initial guesses for a and b. We repeat this process until the ansatz is good enough within some tolerance.

https://qiskit.org/textbook/ch-demos/variational-quantum-regression.html

![xx.JPG](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4RDaRXhpZgAATU0AKgAAAAgABAE7AAIAAAAFAAAISodpAAQAAAABAAAIUJydAAEAAAAKAAAQyOocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEhvZGEAAAAFkAMAAgAAABQAABCekAQAAgAAABQAABCykpEAAgAAAAM4NQAAkpIAAgAAAAM4NQAA6hwABwAACAwAAAiSAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAyMzowMzowOCAyMzoxODozNQAyMDIzOjAzOjA4IDIzOjE4OjM1AAAASABvAGQAYQAAAP/hCxdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDIzLTAzLTA4VDIzOjE4OjM1Ljg1MjwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5Ib2RhPC9yZGY6bGk+PC9yZGY6U2VxPg0KCQkJPC9kYzpjcmVhdG9yPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMABwUFBgUEBwYFBggHBwgKEQsKCQkKFQ8QDBEYFRoZGBUYFxseJyEbHSUdFxgiLiIlKCkrLCsaIC8zLyoyJyorKv/bAEMBBwgICgkKFAsLFCocGBwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKv/AABEIAPkCpQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APpGiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqC6vbezTdcyqmegPU/QU0m9EJu25PRWI/ii1VsRwXDj+9hQD+Zz+lN/4SqD/n0n/Nf8a09jPsR7SHc3aKwv8AhKoP+fSf81/xo/4SqD/n0n/Nf8aPYz7B7WHc3aKwv+Eqg/59J/zX/Gj/AISq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VQwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDn/GOnXd3oyXukAHVdLlF5ZqQP3rKDuiOcYDoWTPbcD2rW0vUrfV9KttQsyTBcxiRNwwQCOhHYjoatVylgW8L+LH0uQqNJ1d2msD08i45aWH6N99ffePSgDq6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACuVnkk8Q+PYrSLnTdBAnuHBP727cfu4+mCEQlzz1eP0NaniTWm0PSGmt4DdX0zCCytQcedM3CqT2Xux7KCe1O8O6O2iaNHbTTfaLp2Mt1cYx50zHLt7DPQdgAKANSiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArO13RYNf0eawuXkh34aKeFtskEinKSIezKQCP14rRooAwvDWs3N6J9M1lVi1jTyFuFXhZlP3ZkH91ufoQR2rdrD8RaA+qeRf6ZMtprFiS1pckZBB+9G4H3o2xgj6EcgVJ4f8QLrKTwXMBstTsyEu7J2yYiehB/iQ9Q3f2IIoA2KKKKACiiigAooooAKKKzdf8Q6V4X0abVdevI7Ozh+9I/cnoABySfQUAaVFcB4T+NXg7xlry6PpV1cRXkilokuoDGJcc4U55OOce1d/QAUUUUAFFFFABRRRQAVFc3MFlay3N3KkMEKF5JJGwqKOSSafJIkMbSSuqIgLMzHAUDuTXJxxnx1dRXVzCy+HbdxJbxSDB1BwflkZf8AnmDyoP3jg4xjIBJoME/iHVl8UakhS3EZTSbV49rRRt96Zs873AHH8KgDqWrqqKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKxNe8OrqksV/Yzmw1e1BFteIM8d0cfxxnup+owea26KAOf0fxMZ79dH162Gm6ztJWEvujuVXq8L/xDuR94dx3roKo6vothrtj9k1S3WeMMHQnho3HR1Ycqw7Ec1hCXxB4XkxciTX9HA/1yL/plv8A7yjiVfcYYejdaAOroqhpGuabr1qbjSbyO5RTtcKfmjb+6y9VPscVfoAKKKKACvnL4+6nfaz8W/C/hS0059XtrdEvpdNik2tdMXYshPQfu4+v+0a+ja8j+IPw68Tz/E/TfHngSSwa/trfyJra9JVW4YBgR1+V8Y4+6OuaAPP01nUfFf7Unhc3XhqbQJ9MtVhlsmlWQoirI4bKgADEgGPavo8axp7a4dHF3EdRWD7SbYH5xHuC7semSBXBfDf4Y3fh7XdQ8WeLr2PUfE2pk+Y8S/urdT/CmeSeBzxxxjqToeBri41Hxt4zvLidZ4Le/SxtSYl3IqIGcbwASNzgYOcbKAO6ooooAKKKCcDJ4FABVLVdXsdEsGvNTuFghUhQT1dj0VR1Zj2A5NY114te9la08I2R1e5zta53bLSE+ry/xY/uoCeMcdam0zwqsV/HqmvXZ1fVYwfLnkTZHb56+VHkhPry3vQBSTTr/wAX3S3OvQyWOjJgwaWzYe5P9+fHQekefdvQdYqhVCqAABgAdqWigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAMPVvCOmapqC6kiyWGqou1dQsm8qbb/dYjh1/2WBHtVR28XaKSVjtvEdqCPlVhbXQHfGf3bn6lK6eigDnIfHWjAhNUa40ec8GLUoDDg+m4/IfqGIretrq3vIRLaTxzxno8ThgfxFPkjSVCkqK6nqrDIrn73wD4YvZDL/ZUdpMcEz6e72kmR0+eIq3Yd6AOiormI/B91ZgjS/Fmu24wBtnmjuhge8yM345pzaF4mE26LxjJs/uSabC36jFAHS1g6P4M0TQtbvdW062dLu9eR5GaVmVTIwaTYpOF3Mqk46kD0qGbRfFEoATxasPvHpkfP8A30xpf+Ec1uVQtz4y1ELtIb7Pa20Zb8TGxH4UAdHWPf8AizQdMcpd6rbLKB/qUffIfoq5P6VnD4eaLM4fVptU1dgMY1DUppY+mP8AVbhH/wCO1uWGjaZpUYTTNOtLNB0W3gWMfoKAMRvEetaqwj8NaBKIz/y/asTbRAZ6rHgyMcdiqjpzSnwhLqpJ8W6pLqsTHmxRfJtfoyA5cezkj2rp6KAGQwxW8KQ28aRRIAqIihVUegA6U+iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q==)

***This algorithm has no known advantage over the most widely-used classical algorithm (Least Squares Method), but does nicely demonstrate the different elements of variational quantum algorithms.
"""

pip install qiskit

pip install pylatexenc

import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import Aer, execute
import pylatexenc
import math
import random
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize



"""#inner product"""

def inner_prod_norm_output(vec1, vec2):
    #first check lengths are equal
    if len(vec1) != len(vec2):
        raise ValueError('Lengths of states are not equal')
    N = len(vec1)
    nqubits = math.ceil(np.log2(N))    # compute how many qubits needed to encode either x or y

    xnorm = np.linalg.norm(vec1)           #sqrt(0^2+1^2+3^2+4^2+5^2+6^2+7^2)        # normalise vectors x and y
    ynorm = np.linalg.norm(vec2)
    vec1 = vec1/xnorm
    vec2= vec2/ynorm
    circ = QuantumCircuit(2*nqubits+1,1)
    circ.h(0)   # create circuit
    circ.initialize(vec1,qubits=range(1,nqubits+1))
    circ.initialize(vec2,range(nqubits+1,2*nqubits+1))
    for i in range(1,nqubits+1):
      circ.cswap(control_qubit=0,target_qubit1=i,target_qubit2=nqubits+i)
    circ.h(0)
    circ.measure(qubit=0,cbit=0)
    shut_number=1000
    job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

    count = job.result().get_counts(circ)
    dot=np.sqrt(2*(count["0"]/shut_number)-1)  #2*p(0)-1   p(0)=number(0)/shut_number

    return dot


def inner_prod_innorm_output(vec1, vec2):
    #first check lengths are equal
    if len(vec1) != len(vec2):
        raise ValueError('Lengths of states are not equal')
    N = len(vec1)
    nqubits = math.ceil(np.log2(N))    # compute how many qubits needed to encode either x or y

    xnorm = np.linalg.norm(vec1)           #sqrt(0^2+1^2+3^2+4^2+5^2+6^2+7^2)        # normalise vectors x and y
    ynorm = np.linalg.norm(vec2)
    vec1 = vec1/xnorm
    vec2= vec2/ynorm
    circ = QuantumCircuit(2*nqubits+1,1)
    circ.h(0)   # create circuit
    circ.initialize(vec1,qubits=range(1,nqubits+1))
    circ.initialize(vec2,range(nqubits+1,2*nqubits+1))
    for i in range(1,nqubits+1):
      circ.cswap(control_qubit=0,target_qubit1=i,target_qubit2=nqubits+i)
    circ.h(0)
    circ.measure(qubit=0,cbit=0)
    shut_number=1000
    job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

    count = job.result().get_counts(circ)
    dot=xnorm*ynorm*np.sqrt(2*(count["0"]/shut_number)-1)  #2*p(0)-1   p(0)=number(0)/shut_number

    return dot

vec1 = np.array([1,0,2,3])
vec2= np.array([0,1,3,1])


print("vec1: ", vec1)
print()
print("vec1: ", vec2)
print()


N = len(vec1)
nqubits = math.ceil(np.log2(N))    # compute how many qubits needed to encode either x or y

xnorm = np.linalg.norm(vec1)           #sqrt(0^2+1^2+3^2+4^2+5^2+6^2+7^2)        # normalise vectors x and y
ynorm = np.linalg.norm(vec2)
vec1 = vec1/xnorm
vec2= vec2/ynorm

circ = QuantumCircuit(2*nqubits+1,1)
circ.h(0)   # create circuit
circ.initialize(vec1,qubits=range(1,nqubits+1))
circ.initialize(vec2,range(nqubits+1,2*nqubits+1))
for i in range(1,nqubits+1):
  circ.cswap(control_qubit=0,target_qubit1=i,target_qubit2=nqubits+i)
circ.h(0)
circ.measure(qubit=0,cbit=0)
shut_number=1000
job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

count = job.result().get_counts(circ)
dot=xnorm*ynorm*np.sqrt(2*(count["0"]/shut_number)-1)  #2*p(0)-1   p(0)=number(0)/shut_number


print("The inner product of x and y equals: ", dot)
circ.draw(output='mpl')

"""#cost function"""

def calculate_cost_function(parameters):

    a, b = parameters

    ansatz = a*x + b                        # compute ansatz
    ansatzNorm = np.linalg.norm(ansatz)     # normalise ansatz

    ansatz = ansatz/ansatzNorm
    print(ansatz)


    y_ansatz = ansatzNorm/ynorm * inner_prod_norm_output(y,ansatz)     # use quantum circuit to test ansatz
                                                           # note the normalisation factors
    return (1-y_ansatz)**2

#first set up the data sets x and y

x = np.arange(0,8,1)
y = x   # + [random.uniform(-1,1) for p in range(8)]    # can add noise here
N = len(x)
nqubits = math.ceil(np.log2(N))

ynorm = np.linalg.norm(y)      # normalise the y data set
y = y/ynorm

a=1
b=2
print("Cost function for a =", a, "and b =", b, "equals:", calculate_cost_function((a,b)))

#first set up the data sets x and y

x = np.arange(0,8,1)
y = x   # + [random.uniform(-1,1) for p in range(8)]    # can add noise here
N = len(x)
nqubits = math.ceil(np.log2(N))

ynorm = np.linalg.norm(y)      # normalise the y data set
y = y/ynorm

x0 = [0.5,0.5]                 # initial guess for a and b

#now use different classical optimisers to see which one works best

out = minimize(calculate_cost_function, x0=x0, method="BFGS", options={'maxiter':200}, tol=1e-6)
out1 = minimize(calculate_cost_function, x0=x0, method="COBYLA", options={'maxiter':200}, tol=1e-6)
out2 = minimize(calculate_cost_function, x0=x0, method="Nelder-Mead", options={'maxiter':200}, tol=1e-6)
out3 = minimize(calculate_cost_function, x0=x0, method="CG", options={'maxiter':200}, tol=1e-6)
out4 = minimize(calculate_cost_function, x0=x0, method="trust-constr", options={'maxiter':200}, tol=1e-6)

out_a1 = out1['x'][0]
out_b1 = out1['x'][1]

out_a = out['x'][0]
out_b = out['x'][1]

out_a2 = out2['x'][0]
out_b2 = out2['x'][1]

out_a3 = out3['x'][0]
out_b3 = out3['x'][1]

out_a4 = out4['x'][0]
out_b4 = out4['x'][1]

plt.scatter(x,y*ynorm)
xfit = np.linspace(min(x), max(x), 100)
plt.plot(xfit, out_a*xfit+out_b, label='BFGS')
plt.plot(xfit, out_a1*xfit+out_b1, label='COBYLA')
plt.plot(xfit, out_a2*xfit+out_b2, label='Nelder-Mead')
plt.plot(xfit, out_a3*xfit+out_b3, label='CG')
plt.plot(xfit, out_a4*xfit+out_b4, label='trust-constr')
plt.legend()
plt.title("y = x")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

"""#general form"""

def calculate_cost_function_n(parameters):

    ansatz = parameters[0]  #a0                 # compute ansatz

    for i in range(1,len(parameters)): #a1,a2,a3,...

        ansatz += parameters[i] * x**i

    ansatzNorm = np.linalg.norm(ansatz)      # normalise ansatz
    ansatz = ansatz/ansatzNorm
    y_ansatz = ansatzNorm/ynorm * inner_prod_norm_output(y,ansatz)     # use quantum circuit to test ansatz
                                                           # note the normalisation factors

    return (1-y_ansatz)**2



x = np.array([1,2,3],4,5,6,7,8])
y = x**2 + [random.uniform(-1,1) for p in range(len(x))]
N = len(x)
nqubits = math.ceil(np.log2(N))

ynorm = np.linalg.norm(y)       #normalise y data set
y = y/ynorm

order = 2

x0 = [random.uniform(0,2) for p in range(order+1)]
print("x0: ",x0)    #random initial guess for a and b

#now use different classical optimisers to see which one works best

out = minimize(calculate_cost_function_n, x0=x0, method="BFGS", options={'maxiter':200}, tol=1e-6)
out1 = minimize(calculate_cost_function_n, x0=x0, method="COBYLA", options={'maxiter':200}, tol=1e-6)
out2 = minimize(calculate_cost_function_n, x0=x0, method="Nelder-Mead", options={'maxiter':200}, tol=1e-6)
out3 = minimize(calculate_cost_function_n, x0=x0, method="CG", options={'maxiter':200}, tol=1e-6)
out4 = minimize(calculate_cost_function_n, x0=x0, method="trust-constr", options={'maxiter':200}, tol=1e-6)

class_fit = np.polyfit(x,y*ynorm,order)
class_fit = class_fit[::-1]

xfit = np.linspace(min(x), max(x), 100)

#draw fited line
def return_fits(xfit):
    c_fit = np.zeros(100)
    q_fit = np.zeros(100)
    q_fit1 = np.zeros(100)
    q_fit2 = np.zeros(100)
    q_fit3 = np.zeros(100)
    q_fit4 = np.zeros(100)
    for i in range(order+1):
        c_fit += xfit**i*class_fit[i]
        q_fit += xfit**i*out['x'][i]
        q_fit1 += xfit**i*out1['x'][i]
        q_fit2 += xfit**i*out2['x'][i]
        q_fit3 += xfit**i*out3['x'][i]
        q_fit4 += xfit**i*out4['x'][i]


    return c_fit, q_fit, q_fit1, q_fit2, q_fit3, q_fit4

c_fit, q_fit, q_fit1, q_fit2, q_fit3, q_fit4 = return_fits(xfit)

plt.scatter(x,y*ynorm)
xfit = np.linspace(min(x), max(x), 100)
plt.plot(xfit, c_fit, label='Classical')
plt.plot(xfit, q_fit, label='BFGS')
plt.plot(xfit, q_fit1, label='COBYLA')
plt.plot(xfit, q_fit2, label='Nelder-Mead')
plt.plot(xfit, q_fit3, label='CG')
plt.plot(xfit, q_fit4, label='trust-constr')
plt.legend()
plt.title("$y = x^2$ + Random Perturbation")
plt.xlabel("x")
plt.ylabel("y")
plt.show()





"""chekpoint"""

x = np.array([4,5,6,7])
y = x + [random.uniform(-1,1) for p in range(len(x))]
N = len(x)
nqubits = math.ceil(np.log2(N))

ynorm = np.linalg.norm(y)       #normalise y data set
y = y/ynorm

xnorm = np.linalg.norm(x)       #normalise y data set
x = x/xnorm
plt.plot(x,y)
theta_init=np.random.random(size=nqubits)*2*np.pi
print(theta_init)

N = len(x_test)
nqubits = math.ceil(np.log2(N))


norm = np.linalg.norm(x_test)
x_test_norm  = x_test /norm



circ = QuantumCircuit(nqubits)
circ.initialize(x_test_norm,qubits=range(0,nqubits))
for j,theta in zip(np.arange(0,nqubits),theta_optimized):
  circ.ry(theta,j)
circ.measure(qubit=0,cbit=0)
shut_number=1000
job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

count = job.result().get_counts(circ)

circ = QuantumCircuit(2*nqubits+1,1)
circ.h(0)   # create circuit
circ.initialize(x,qubits=range(1,nqubits+1))
circ.initialize(y,range(nqubits+1,2*nqubits+1))
for j,theta in zip(np.arange(nqubits+1,2*nqubits+1),theta_init):
  circ.ry(theta,j)
for i in range(1,nqubits+1):
  circ.cswap(control_qubit=0,target_qubit1=i,target_qubit2=nqubits+i)
circ.h(0)
circ.measure(qubit=0,cbit=0)
shut_number=1000
job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

count = job.result().get_counts(circ)
dot=xnorm*ynorm*np.sqrt(2*(count["0"]/shut_number)-1)  #2*p(0)-1   p(0)=number(0)/shut_number


print("The inner product of x and y equals: ", dot)
circ.draw(output='mpl')

def calculate_cost_function_n(theta_ini):
    #first check lengths are equal
    x = np.array([4,5,6,7])
    y = x+2
    print(x,y)
    N = len(x)
    nqubits = math.ceil(np.log2(N))

    ynorm = np.linalg.norm(y)       #normalise y data set
    y = y/ynorm

    xnorm = np.linalg.norm(x)       #normalise y data set
    x = x/xnorm



    circ = QuantumCircuit(2*nqubits+1,1)
    circ.h(0)   # create circuit
    circ.initialize(x,qubits=range(1,nqubits+1))
    circ.initialize(y,range(nqubits+1,2*nqubits+1))
    for j,theta in zip(np.arange(nqubits+1,2*nqubits+1),theta_init):
      circ.ry(theta,j)
    for i in range(1,nqubits+1):
      circ.cswap(control_qubit=0,target_qubit1=i,target_qubit2=nqubits+i)
    circ.h(0)
    circ.measure(qubit=0,cbit=0)
    shut_number=1000
    job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

    count = job.result().get_counts(circ)
    dot=np.sqrt(2*(count["0"]/shut_number)-1)  #2*p(0)-1   p(0)=number(0)/shut_number


    return (1-dot)**2


def test(x_test,theta_optimized):
  #first check lengths are equal

    N = len(x_test)
    nqubits = math.ceil(np.log2(N))


    norm = np.linalg.norm(x_test)
    x_test_norm  = x_test /norm



    circ = QuantumCircuit(nqubits)
    circ.initialize(x_test_norm,qubits=range(0,nqubits))
    for j,theta in zip(np.arange(0,nqubits),theta_optimized):
      circ.ry(theta,j)
    circ.measure(qubit=0,cbit=0)
    shut_number=1000
    job = execute(circ, backend=Aer.get_backend('qasm_simulator'),shots=shut_number)

    count = job.result().get_counts(circ)
    return count

out  =  minimize(calculate_cost_function_n,  x0=theta_init, method="BFGS", options={'maxiter':200}, tol=1e-6)
out1 = minimize(calculate_cost_function_n, x0=theta_init, method="COBYLA", options={'maxiter':200}, tol=1e-6)
out2 = minimize(calculate_cost_function_n, x0=theta_init, method="Nelder-Mead", options={'maxiter':200}, tol=1e-6)
out3 = minimize(calculate_cost_function_n, x0=theta_init, method="CG", options={'maxiter':200}, tol=1e-6)
out4 = minimize(calculate_cost_function_n, x0=theta_init, method="trust-constr", options={'maxiter':200}, tol=1e-6)

out2['x']

